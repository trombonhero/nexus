<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS - Connect the System</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>


    <style>
        /* Custom Animations not in Tailwind default */
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 5px rgba(6, 182, 212, 0.5)); }
            50% { filter: drop-shadow(0 0 15px rgba(6, 182, 212, 0.8)); }
        }
        .animate-glow { animation: pulse-glow 2s infinite; }
        
        /* Disable selection for game feel */
        body { user-select: none; -webkit-user-select: none; touch-action: none; }
        
        /* Custom Scrollbar hide */
        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body class="bg-stone-950 text-stone-200 font-sans h-screen w-screen overflow-hidden flex flex-col items-center justify-center">


    <!-- HUD -->
    <div class="absolute top-8 text-center z-10 pointer-events-none">
        <h1 class="text-4xl font-light tracking-[0.3em] text-cyan-500 drop-shadow-lg">NEXUS</h1>
        <p id="status-text" class="mt-2 text-xs font-bold uppercase tracking-widest text-stone-500 transition-colors duration-300">
            Connetti il sistema
        </p>
    </div>


    <!-- MAIN GAME AREA -->
    <div class="relative group touch-none">
        <!-- SVG Container -->
        <div id="game-container" class="relative bg-stone-900 rounded-2xl border border-stone-800 shadow-2xl transition-all duration-300">
            <svg id="game-canvas" class="block cursor-crosshair" style="touch-action: none;">
                <!-- Content injected via JS -->
            </svg>
        </div>


        <!-- WIN OVERLAY -->
        <div id="win-screen" class="absolute inset-0 bg-stone-950/90 backdrop-blur-sm rounded-2xl flex flex-col items-center justify-center z-50 opacity-0 pointer-events-none transition-opacity duration-500">
            <div class="bg-cyan-500/10 p-6 rounded-full mb-4 ring-1 ring-cyan-500 shadow-[0_0_30px_rgba(6,182,212,0.3)]">
                <i data-lucide="check" class="w-12 h-12 text-cyan-400"></i>
            </div>
            <h2 class="text-3xl font-bold text-white mb-1 tracking-wider">CONNESSO</h2>
            <p class="text-stone-400 text-sm mb-8">Sistema sincronizzato.</p>
            <button onclick="game.newGame()" class="px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white rounded-full font-bold shadow-lg shadow-cyan-900/40 transition-all active:scale-95 flex items-center gap-2 pointer-events-auto">
                Prossima Configurazione <i data-lucide="arrow-right" class="w-4 h-4"></i>
            </button>
        </div>
    </div>


    <!-- CONTROLS -->
    <div class="absolute bottom-8 flex gap-4 z-10">
        <button onclick="game.newGame()" class="p-4 bg-stone-900 border border-stone-800 rounded-full text-stone-500 hover:text-cyan-400 hover:border-cyan-900 hover:bg-stone-800 transition-all shadow-lg active:scale-95" title="Nuova Partita">
            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
        </button>
        <button onclick="toggleTutorial()" class="p-4 bg-stone-900 border border-stone-800 rounded-full text-stone-500 hover:text-cyan-400 hover:border-cyan-900 hover:bg-stone-800 transition-all shadow-lg active:scale-95" title="Aiuto">
            <i data-lucide="info" class="w-5 h-5"></i>
        </button>
    </div>


    <!-- TUTORIAL MODAL -->
    <div id="tutorial-modal" class="fixed inset-0 bg-black/80 z-[60] flex items-center justify-center p-4 backdrop-blur-sm transition-opacity duration-300">
        <div class="bg-stone-900 border border-stone-800 p-8 rounded-2xl max-w-sm w-full shadow-2xl relative">
            <button onclick="toggleTutorial()" class="absolute top-4 right-4 text-stone-500 hover:text-white"><i data-lucide="x" class="w-6 h-6"></i></button>
            
            <div class="flex items-center gap-2 mb-6 text-cyan-400 font-bold text-lg">
                <i data-lucide="mouse-pointer-2" class="w-5 h-5"></i> Guida Rapida
            </div>
            
            <ul class="space-y-4 text-stone-300 text-sm leading-relaxed mb-8">
                <li class="flex gap-3 items-start">
                    <span class="bg-stone-800 w-6 h-6 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold text-cyan-500 border border-stone-700">1</span>
                    <span><strong>Trascina</strong> da un'isola all'altra per creare un ponte di connessione.</span>
                </li>
                <li class="flex gap-3 items-start">
                    <span class="bg-stone-800 w-6 h-6 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold text-cyan-500 border border-stone-700">2</span>
                    <span>Il numero indica quanti ponti servono a quell'isola.</span>
                </li>
                <li class="flex gap-3 items-start">
                    <span class="bg-stone-800 w-6 h-6 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold text-cyan-500 border border-stone-700">3</span>
                    <span><strong>Clicca su una linea</strong> per rimuoverla o ridurla.</span>
                </li>
                <li class="flex gap-3 items-start">
                    <span class="bg-stone-800 w-6 h-6 flex-shrink-0 flex items-center justify-center rounded-full text-xs font-bold text-cyan-500 border border-stone-700">4</span>
                    <span>I ponti non possono incrociarsi. Tutto deve essere unito.</span>
                </li>
            </ul>
            
            <button onclick="toggleTutorial()" class="w-full py-3 bg-stone-800 hover:bg-stone-700 text-white rounded-lg font-bold transition border border-stone-700">
                Ho capito
            </button>
        </div>
    </div>


    <!-- JAVASCRIPT LOGIC -->
    <script>
        // --- CONFIGURAZIONE ---
        const CONFIG = {
            GRID_SIZE: 7,
            CELL_SIZE: 55,
            PADDING: 40,
            TARGET_ISLAND_COUNT_MIN: 10, // Difficoltà standard minima
            TARGET_ISLAND_COUNT_MAX: 15  // Difficoltà standard massima
        };


        // --- UTILITIES GEOMETRICHE ---
        const intersects = (p1, p2, p3, p4) => {
            if ((p1.x === p3.x && p1.y === p3.y) || (p1.x === p4.x && p1.y === p4.y) ||
                (p2.x === p3.x && p2.y === p3.y) || (p2.x === p4.x && p4.y === p4.y)) return false;


            const vertical1 = p1.x === p2.x;
            const vertical2 = p3.x === p4.x;
            if (vertical1 === vertical2) return false; // Parallele (semplificato)


            if (!vertical1) {
                return (p3.x > Math.min(p1.x, p2.x) && p3.x < Math.max(p1.x, p2.x) &&
                        p1.y > Math.min(p3.y, p4.y) && p1.y < Math.max(p3.y, p4.y));
            } else {
                return (p1.y > Math.min(p3.y, p4.y) && p1.y < Math.max(p3.y, p4.y) &&
                        p3.x > Math.min(p1.x, p2.x) && p3.x < Math.max(p1.x, p2.x));
            }
        };


        const getCoords = (gx, gy) => ({ 
            x: gx * CONFIG.CELL_SIZE + CONFIG.PADDING, 
            y: gy * CONFIG.CELL_SIZE + CONFIG.PADDING 
        });


        // --- MOTORE DI GIOCO ---
        class NexusGame {
            constructor() {
                this.svg = document.getElementById('game-canvas');
                this.container = document.getElementById('game-container');
                this.statusText = document.getElementById('status-text');
                this.winScreen = document.getElementById('win-screen');
                
                this.level = [];
                this.bridges = [];
                this.dragState = { active: false, startId: null, currentPos: null, targetId: null, status: 'neutral' };
                
                this.setupCanvas();
                this.attachEvents();
                this.newGame();
            }


            setupCanvas() {
                const size = CONFIG.GRID_SIZE * CONFIG.CELL_SIZE + CONFIG.PADDING * 2;
                this.svg.setAttribute('width', size);
                this.svg.setAttribute('height', size);
                this.svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
                this.container.style.width = `${size}px`;
                this.container.style.height = `${size}px`;
            }


            generateLevel() {
                let isValidGeneration = false;
                let finalIslands = [];
                let existingBridges = []; // Soluzione interna


                // Loop finché non otteniamo una mappa "Standard" (né troppo vuota né troppo piena)
                while (!isValidGeneration) {
                    let islands = [];
                    existingBridges = [];
                    const positions = [];


                    // 1. Crea Griglia
                    for(let y=0; y<CONFIG.GRID_SIZE; y++) {
                        for(let x=0; x<CONFIG.GRID_SIZE; x++) {
                            if (Math.random() > 0.50) positions.push({x, y, id: `${x}-${y}`});
                        }
                    }


                    if (positions.length < CONFIG.TARGET_ISLAND_COUNT_MIN) continue;


                    // 2. Crea Albero di Connessione (Spanning Tree)
                    const connected = [positions[Math.floor(Math.random() * positions.length)]];
                    const unconnect = positions.filter(p => p !== connected[0]);


                    const isPathClear = (p1, p2) => {
                        // Ostacoli Isole
                        for (let other of positions) {
                            if (other === p1 || other === p2) continue;
                            if (p1.x === p2.x && other.x === p1.x) { 
                                if (other.y > Math.min(p1.y, p2.y) && other.y < Math.max(p1.y, p2.y)) return false;
                            }
                            if (p1.y === p2.y && other.y === p1.y) { 
                                if (other.x > Math.min(p1.x, p2.x) && other.x < Math.max(p1.x, p2.x)) return false;
                            }
                        }
                        // Incroci Ponti Esistenti
                        for (let b of existingBridges) {
                            if (intersects(p1, p2, b.p1, b.p2)) return false;
                            // Sovrapposizione colineare
                            if ((p1.x === p2.x && b.p1.x === b.p2.x && p1.x === b.p1.x) ||
                                (p1.y === p2.y && b.p1.y === b.p2.y && p1.y === b.p1.y)) {
                                const min1 = p1.x === p2.x ? Math.min(p1.y, p2.y) : Math.min(p1.x, p2.x);
                                const max1 = p1.x === p2.x ? Math.max(p1.y, p2.y) : Math.max(p1.x, p2.x);
                                const min2 = b.p1.x === b.p2.x ? Math.min(b.p1.y, b.p2.y) : Math.min(b.p1.x, b.p2.x);
                                const max2 = b.p1.x === b.p2.x ? Math.max(b.p1.y, b.p2.y) : Math.max(b.p1.x, b.p2.x);
                                if (min1 < max2 && max1 > min2) return false;
                            }
                        }
                        return true;
                    };


                    let attempts = 0;
                    while(unconnect.length > 0 && attempts < 2000) {
                        attempts++;
                        const source = connected[Math.floor(Math.random() * connected.length)];
                        const candidates = unconnect.filter(target => {
                            if (source.x !== target.x && source.y !== target.y) return false;
                            return isPathClear(source, target);
                        });


                        if (candidates.length > 0) {
                            const target = candidates[Math.floor(Math.random() * candidates.length)];
                            const count = Math.random() > 0.6 ? 2 : 1;
                            existingBridges.push({ p1: source, p2: target, count });
                            connected.push(target);
                            unconnect.splice(unconnect.indexOf(target), 1);
                        }
                    }


                    // Aggiungi cicli extra
                    for (let i=0; i < connected.length; i++) {
                        if (Math.random() > 0.8) {
                            const p1 = connected[i];
                            const p2 = connected[Math.floor(Math.random() * connected.length)];
                            if (p1 !== p2 && (p1.x === p2.x || p1.y === p2.y)) {
                                if (isPathClear(p1, p2)) existingBridges.push({ p1, p2, count: 1 });
                            }
                        }
                    }


                    // Filtra e calcola requisiti
                    finalIslands = positions.map(pos => {
                        let req = 0;
                        existingBridges.forEach(b => { if (b.p1 === pos || b.p2 === pos) req += b.count; });
                        return { ...pos, req };
                    }).filter(isl => isl.req > 0 && isl.req <= 8);


                    // Check Validità Standardizzata
                    if (finalIslands.length >= CONFIG.TARGET_ISLAND_COUNT_MIN && 
                        finalIslands.length <= CONFIG.TARGET_ISLAND_COUNT_MAX) {
                        isValidGeneration = true;
                    }
                }
                
                return finalIslands;
            }


            newGame() {
                this.level = this.generateLevel();
                this.bridges = [];
                this.dragState = { active: false, startId: null, currentPos: null, targetId: null, status: 'neutral' };
                this.winScreen.style.opacity = '0';
                this.winScreen.style.pointerEvents = 'none';
                this.render();
            }


            // --- INPUT & EVENTI ---
            attachEvents() {
                // Drag start dalle isole (gestito nel render per ogni isola)
                
                // Drag move globale
                window.addEventListener('pointermove', (e) => this.handleMove(e));
                window.addEventListener('pointerup', (e) => this.handleUp(e));
                
                // Touch prevent scroll
                document.body.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }


            getPointerPos(e) {
                const rect = this.svg.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }


            handleDown(e, islandId) {
                e.stopPropagation();
                e.preventDefault(); // Importante per touch
                const pos = this.getPointerPos(e);
                this.dragState = {
                    active: true,
                    startId: islandId,
                    currentPos: pos,
                    targetId: null,
                    status: 'neutral'
                };
                this.updateStatus("Trascina verso un'isola...");
                this.render();
            }


            handleMove(e) {
                if (!this.dragState.active) return;
                const pos = this.getPointerPos(e);
                
                // Logica Hover Target
                let target = null;
                let status = 'neutral';
                let msg = "";


                for (let isl of this.level) {
                    if (isl.id === this.dragState.startId) continue;
                    const coords = getCoords(isl.x, isl.y);
                    const dist = Math.sqrt(Math.pow(coords.x - pos.x, 2) + Math.pow(coords.y - pos.y, 2));
                    
                    if (dist < 30) {
                        target = isl.id;
                        const validation = this.validateConnection(this.dragState.startId, isl.id);
                        status = validation.valid ? 'valid' : 'invalid';
                        msg = validation.reason;
                        break;
                    }
                }


                if (!target) {
                    // Snap Guide Logic
                    const startIsl = this.level.find(i => i.id === this.dragState.startId);
                    const s = getCoords(startIsl.x, startIsl.y);
                    const dx = Math.abs(pos.x - s.x);
                    const dy = Math.abs(pos.y - s.y);
                    if (dx > dy * 2) msg = "Orizzontale...";
                    else if (dy > dx * 2) msg = "Verticale...";
                    else msg = "Cerca un'isola in linea retta";
                }


                this.dragState.currentPos = pos;
                this.dragState.targetId = target;
                this.dragState.status = status;
                
                this.updateStatus(msg);
                this.render();
            }


            handleUp(e) {
                if (!this.dragState.active) return;


                if (this.dragState.status === 'valid' && this.dragState.targetId) {
                    this.modifyBridge(this.dragState.startId, this.dragState.targetId);
                }


                this.dragState = { active: false, startId: null, currentPos: null, targetId: null, status: 'neutral' };
                this.checkWin();
                this.updateStatus("Connetti il sistema");
                this.render();
            }


            handleBridgeClick(e, bridgeIndex) {
                e.stopPropagation();
                const bridge = this.bridges[bridgeIndex];
                
                // Opzione: Rimuovi completamente (più veloce) o Cicla in giù (2->1->0)
                // L'utente ha chiesto "cliccare per cancellare", quindi riduciamo
                if (bridge.count === 2) {
                    bridge.count = 1;
                } else {
                    this.bridges.splice(bridgeIndex, 1);
                }
                
                this.checkWin();
                this.render();
            }


            modifyBridge(id1, id2) {
                const [from, to] = [id1, id2].sort();
                const idx = this.bridges.findIndex(b => b.from === from && b.to === to);
                if (idx >= 0) {
                    if (this.bridges[idx].count === 1) this.bridges[idx].count = 2;
                    else this.bridges.splice(idx, 1);
                } else {
                    this.bridges.push({ from, to, count: 1 });
                }
            }


            validateConnection(id1, id2) {
                const isl1 = this.level.find(i => i.id === id1);
                const isl2 = this.level.find(i => i.id === id2);
                
                // Ortogonalità
                if (isl1.x !== isl2.x && isl1.y !== isl2.y) return { valid: false, reason: "Solo linee rette" };


                // Ostacoli
                const minX = Math.min(isl1.x, isl2.x); const maxX = Math.max(isl1.x, isl2.x);
                const minY = Math.min(isl1.y, isl2.y); const maxY = Math.max(isl1.y, isl2.y);
                const blocked = this.level.some(i => {
                    if (i.id === id1 || i.id === id2) return false;
                    if (isl1.x === isl2.x) return i.x === isl1.x && i.y > minY && i.y < maxY;
                    return i.y === isl1.y && i.x > minX && i.x < maxX;
                });
                if (blocked) return { valid: false, reason: "Isola nel mezzo" };


                // Incroci
                const hasCrossing = this.bridges.some(b => {
                    const b1 = this.level.find(i => i.id === b.from);
                    const b2 = this.level.find(i => i.id === b.to);
                    if ((b.from === id1 && b.to