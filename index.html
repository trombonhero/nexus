<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS - Zero Dependency</title>
    <style>
        /* RESET & BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            background-color: #0c0a09; /* Stone 950 */
            color: #e7e5e4; /* Stone 200 */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
            user-select: none; -webkit-user-select: none;
            touch-action: none;
        }


        /* TYPOGRAPHY */
        h1 {
            font-size: 2.5rem; letter-spacing: 0.3em; font-weight: 300;
            color: #06b6d4; /* Cyan 500 */
            text-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
            margin: 0 0 0.5rem 0;
            text-align: center;
        }
        .status {
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.2em;
            color: #78716c; font-weight: bold; margin-bottom: 1.5rem;
            min-height: 1rem;
        }
        .status.error { color: #ef4444; }
        .status.success { color: #06b6d4; }


        /* GAME CONTAINER */
        .game-wrapper {
            position: relative;
            background-color: #1c1917; /* Stone 900 */
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid #292524;
            padding: 0;
            line-height: 0; /* Fix svg spacing */
        }


        svg {
            display: block;
            cursor: crosshair;
        }


        /* CONTROLS */
        .controls {
            margin-top: 2rem;
            display: flex; gap: 1rem;
        }
        button {
            background: #1c1917; border: 1px solid #292524;
            color: #a8a29e;
            padding: 1rem;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center;
        }
        button:active { transform: scale(0.95); }
        button:hover { color: #06b6d4; border-color: #0e7490; background: #292524; }
        
        /* ICONS SVG STYLE */
        .icon { width: 24px; height: 24px; stroke: currentColor; stroke-width: 2; fill: none; stroke-linecap: round; stroke-linejoin: round; }


        /* MODAL & OVERLAY */
        .overlay {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(12, 10, 9, 0.9);
            backdrop-filter: blur(4px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-radius: 1rem;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 10;
        }
        .overlay.visible { opacity: 1; pointer-events: auto; }
        
        .win-content { text-align: center; animation: float 3s ease-in-out infinite; }
        .win-icon { color: #06b6d4; width: 64px; height: 64px; margin-bottom: 1rem; }
        .win-title { font-size: 2rem; font-weight: bold; color: white; margin: 0; letter-spacing: 0.1em; }
        .win-btn {
            margin-top: 1.5rem;
            background: #0891b2; color: white; border: none;
            padding: 0.8rem 2rem; border-radius: 2rem;
            font-weight: bold; font-size: 1rem;
            width: auto;
        }
        .win-btn:hover { background: #06b6d4; color: white; }


        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        /* ANIMATIONS */
        .glow { filter: drop-shadow(0 0 8px rgba(34, 211, 238, 0.6)); }
    </style>
</head>
<body>


    <!-- HEADER -->
    <div>
        <h1>NEXUS</h1>
        <div id="status" class="status">SISTEMA ONLINE</div>
    </div>


    <!-- GAME BOARD -->
    <div class="game-wrapper">
        <svg id="canvas"></svg>


        <!-- WIN SCREEN -->
        <div id="win-screen" class="overlay">
            <div class="win-content">
                <svg class="icon win-icon" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>
                <h2 class="win-title">CONNESSO</h2>
                <button class="win-btn" onclick="game.newGame()">Prossimo Livello</button>
            </div>
        </div>


        <!-- HELP SCREEN -->
        <div id="help-screen" class="overlay" style="z-index: 20;">
            <div style="max-width: 250px; text-align: left; color: #d6d3d1;">
                <h3 style="color: #06b6d4; margin-bottom: 1rem;">Guida Rapida</h3>
                <ul style="font-size: 0.9rem; line-height: 1.6; padding-left: 1.2rem;">
                    <li>Trascina tra le isole per creare ponti.</li>
                    <li>Il numero indica i ponti necessari.</li>
                    <li>Clicca su una linea per rimuoverla.</li>
                    <li>Nessun incrocio.</li>
                </ul>
                <button class="win-btn" style="width: 100%; margin-top: 1rem; background: #292524;" onclick="document.getElementById('help-screen').classList.remove('visible')">Chiudi</button>
            </div>
        </div>
    </div>


    <!-- CONTROLS -->
    <div class="controls">
        <button onclick="game.newGame()" title="Reset">
            <svg class="icon" viewBox="0 0 24 24"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        </button>
        <button onclick="document.getElementById('help-screen').classList.add('visible')" title="Aiuto">
            <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
        </button>
    </div>


    <script>
        // --- GAME LOGIC ---
        const CONFIG = { GRID: 7, CELL: 50, PAD: 30 };


        class Nexus {
            constructor() {
                this.svg = document.getElementById('canvas');
                this.statusEl = document.getElementById('status');
                this.winScreen = document.getElementById('win-screen');
                
                // Set SVG Size
                const size = CONFIG.GRID * CONFIG.CELL + CONFIG.PAD * 2;
                this.svg.setAttribute('width', size);
                this.svg.setAttribute('height', size);
                
                this.level = [];
                this.bridges = [];
                this.drag = { active: false, start: null, curr: null, target: null, valid: false };


                // Bind Events
                this.svg.addEventListener('pointerdown', e => this.onDown(e));
                window.addEventListener('pointermove', e => this.onMove(e));
                window.addEventListener('pointerup', e => this.onUp(e));
                
                this.newGame();
            }


            // --- GENERATION ---
            generate() {
                // Semplice generatore robusto
                let nodes = [];
                let attempts = 0;
                
                while(attempts < 100) {
                    attempts++;
                    nodes = [];
                    // 1. Random Nodes
                    for(let y=0; y<CONFIG.GRID; y++) {
                        for(let x=0; x<CONFIG.GRID; x++) {
                            if(Math.random() > 0.6) nodes.push({x, y, id: `${x}-${y}`, req: 0});
                        }
                    }
                    if(nodes.length < 6) continue;


                    // 2. Simple Spanning Tree
                    let connected = [nodes[0]];
                    let pool = nodes.slice(1);
                    let bridges = [];
                    let fail = false;


                    while(pool.length > 0) {
                        let possible = [];
                        // Trova tutte le connessioni possibili tra connected e pool
                        for(let c of connected) {
                            for(let p of pool) {
                                if(this.canConnect(c, p, nodes, bridges)) possible.push({src:c, dst:p});
                            }
                        }
                        if(possible.length === 0) { fail = true; break; }
                        
                        // Pick random
                        let edge = possible[Math.floor(Math.random() * possible.length)];
                        bridges.push({p1: edge.src, p2: edge.dst, count: Math.random()>0.5?1:2});
                        connected.push(edge.dst);
                        pool = pool.filter(n => n !== edge.dst);
                    }
                    if(fail) continue;


                    // 3. Add random extra cycles
                    for(let i=0; i<5; i++) {
                        let n1 = nodes[Math.floor(Math.random()*nodes.length)];
                        let n2 = nodes[Math.floor(Math.random()*nodes.length)];
                        if(n1!==n2 && this.canConnect(n1, n2, nodes, bridges)) {
                             bridges.push({p1: n1, p2: n2, count: 1});
                        }
                    }


                    // 4. Calculate Reqs
                    nodes.forEach(n => {
                        n.req = 0;
                        bridges.forEach(b => { if(b.p1===n || b.p2===n) n.req += b.count; });
                    });
                    
                    // Filter 0 reqs (should not happen but safe)
                    this.level = nodes.filter(n => n.req > 0 && n.req <= 8);
                    if(this.level.length >= 6) return;
                }
                
                // Fallback level
                this.level = [
                    {x:2,y:2,req:2,id:'a'}, {x:4,y:2,req:2,id:'b'},
                    {x:2,y:4,req:2,id:'c'}, {x:4,y:4,req:2,id:'d'}
                ];
            }


            canConnect(n1, n2, allNodes, currentBridges) {
                if(n1.x !== n2.x && n1.y !== n2.y) return false; // Not orthogonal
                // Obstacles
                const minX=Math.min(n1.x,n2.x), maxX=Math.max(n1.x,n2.x);
                const minY=Math.min(n1.y,n2.y), maxY=Math.max(n1.y,n2.y);
                for(let n of allNodes) {
                    if(n===n1 || n===n2) continue;
                    if(n.x>=minX && n.x<=maxX && n.y>=minY && n.y<=maxY && (n.x===n1.x || n.y===n1.y)) return false;
                }
                // Crossing
                for(let b of currentBridges) {
                    if(this.intersects(n1, n2, b.p1, b.p2)) return false;
                    // Overlap logic simplified
                     if((n1.x===n2.x && b.p1.x===b.p2.x && n1.x===b.p1.x && minY < Math.max(b.p1.y,b.p2.y) && maxY > Math.min(b.p1.y,b.p2.y)) ||
                        (n1.y===n2.y && b.p1.y===b.p2.y && n1.y===b.p1.y && minX < Math.max(b.p1.x,b.p2.x) && maxX > Math.min(b.p1.x,b.p2.x))) return false;
                }
                return true;
            }


            intersects(a, b, c, d) {
                let v1 = a.x===b.x, v2 = c.x===d.x;
                if(v1===v2) return false;
                let x1=Math.min(a.x,b.x), x2=Math.max(a.x,b.x), y1=Math.min(a.y,b.y), y2=Math.max(a.y,b.y);
                let x3=Math.min(c.x,d.x), x4=Math.max(c.x,d.x), y3=Math.min(c.y,d.y), y4=Math.max(c.y,d.y);
                return v1 ? (x1>x3 && x1<x4 && y3>y1 && y3<y2) : (x3>x1 && x3<x2 && y1>y3 && y1<y4);
            }


            // --- INPUT ---
            getPos(e) {
                const r = this.svg.getBoundingClientRect();
                return { x: e.clientX - r.left, y: e.clientY - r.top };
            }


            onDown(e) {
                const pos = this.getPos(e);
                
                // Check clicking a bridge (simple hitbox)
                for(let i=0; i<this.bridges.length; i++) {
                    const b = this.bridges[i];
                    const n1 = this.level.find(n=>n.id===b.from), n2 = this.level.find(n=>n.id===b.to);
                    const p1 = this.gridToPx(n1.x,n1.y), p2 = this.gridToPx(n2.x,n2.y);
                    // Distance to segment
                    const A=pos.x-p1.x, B=pos.y-p1.y, C=p2.x-p1.x, D=p2.y-p1.y;
                    const dot = A*C+B*D, len_sq = C*C+D*D;
                    let param = len_sq !== 0 ? dot/len_sq : -1;
                    let xx = (param<0?p1.x:(param>1?p2.x:p1.x+param*C));
                    let yy = (param<0?p1.y:(param>1?p2.y:p1.y+param*D));
                    if(Math.hypot(pos.x-xx, pos.y-yy) < 15) {
                        if(b.count===2) b.count=1; else this.bridges.splice(i,1);
                        this.render(); this.checkWin(); return;
                    }
                }


                // Check clicking an island
                for(let n of this.level) {
                    const p = this.gridToPx(n.x, n.y);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < 25) {
                        this.drag = { active: true, start: n.id, curr: pos, target: null, valid: false };
                        this.setStatus("Trascina verso un'isola...", "");
                        this.render();
                        return;
                    }
                }
            }


            onMove(e) {
                if(!this.drag.active) return;
                const pos = this.getPos(e);
                this.drag.curr = pos;
                
                let target = null, valid = false, msg = "";
                
                for(let n of this.level) {
                    if(n.id === this.drag.start) continue;
                    const p = this.gridToPx(n.x, n.y);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < 25) {
                        target = n.id;
                        // Validation logic reuse
                        const src = this.level.find(x=>x.id===this.drag.start);
                        // Mock bridge format for check
                        if(this.canConnect(src, n, this.level, this.bridges.map(b=>{
                             return {p1:this.level.find(x=>x.id===b.from), p2:this.level.find(x=>x.id===b.to)};
                        }))) {
                             valid = true; msg = "Connetti!";
                        } else {
                             msg = "Non valido";
                        }
                        break;
                    }
                }
                
                if(!target) {
                    // Guide Text
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.gridToPx(src.x, src.y);
                    if(Math.abs(pos.x-p.x) > Math.abs(pos.y-p.y)*2) msg="Orizzontale...";
                    else if(Math.abs(pos.y-p.y) > Math.abs(pos.x-p.x)*2) msg="Verticale...";
                }


                this.drag.target = target;
                this.drag.valid = valid;
                this.setStatus(msg, valid ? "success" : (target?"error":""));
                this.render();
            }


            onUp(e) {
                if(!this.drag.active) return;
                if(this.drag.valid && this.drag.target) {
                    // Add/Mod bridge
                    const [u, v] = [this.drag.start, this.drag.target].sort();
                    const ex = this.bridges.find(b => b.from===u && b.to===v);
                    if(ex) { if(ex.count===1) ex.count=2; else this.bridges = this.bridges.filter(b=>b!==ex); }
                    else { this.bridges.push({from:u, to:v, count:1}); }
                }
                this.drag.active = false;
                this.setStatus("SISTEMA ONLINE", "");
                this.render();
                this.checkWin();
            }


            // --- RENDER ---
            gridToPx(x, y) { return { x: x * CONFIG.CELL + CONFIG.PAD, y: y * CONFIG.CELL + CONFIG.PAD }; }
            
            setStatus(txt, type) {
                this.statusEl.textContent = txt;
                this.statusEl.className = "status " + type;
            }


            render() {
                let html = '';
                
                // Grid Dots
                for(let y=0; y<CONFIG.GRID; y++) for(let x=0; x<CONFIG.GRID; x++) {
                    const p = this.gridToPx(x, y);
                    html += `<circle cx="${p.x}" cy="${p.y}" r="1" fill="#44403c"/>`;
                }


                // Bridges
                this.bridges.forEach(b => {
                    const n1 = this.level.find(n=>n.id===b.from), n2 = this.level.find(n=>n.id===b.to);
                    const p1 = this.gridToPx(n1.x, n1.y), p2 = this.gridToPx(n2.x, n2.y);
                    const off = 3;
                    
                    // Hitbox invisible
                    html += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="transparent" stroke-width="20"/>`;
                    
                    if(b.count===1) {
                         html += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#06b6d4" stroke-width="4" stroke-opacity="0.6"/>`;
                    } else {
                         const vert = n1.x===n2.x;
                         html += `<line x1="${vert?p1.x-off:p1.x}" y1="${vert?p1.y:p1.y-off}" x2="${vert?p2.x-off:p2.x}" y2="${vert?p2.y:p2.y-off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6"/>`;
                         html += `<line x1="${vert?p1.x+off:p1.x}" y1="${vert?p1.y:p1.y+off}" x2="${vert?p2.x+off:p2.x}" y2="${vert?p2.y:p2.y+off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6"/>`;
                    }
                });


                // Drag Line
                if(this.drag.active) {
                    const n = this.level.find(x=>x.id===this.drag.start);
                    const p = this.gridToPx(n.x, n.y);
                    let end = this.drag.curr;
                    let col = "#fbbf24"; // Amber


                    if(this.drag.target) {
                        const t = this.level.find(x=>x.id===this.drag.target);
                        end = this.gridToPx(t.x, t.y);
                        col = this.drag.valid ? "#06b6d4" : "#ef4444";
                    } else {
                        // Axis snap check visual only
                        if(Math.abs(end.x-p.x) > Math.abs(end.y-p.y)) end.y = p.y; else end.x = p.x;
                    }
                    html += `<line x1="${p.x}" y1="${p.y}" x2="${end.x}" y2="${end.y}" stroke="${col}" stroke-width="2" stroke-dasharray="5,5"/>`;
                }


                // Islands
                this.level.forEach(n => {
                    const p = this.gridToPx(n.x, n.y);
                    let cur = 0;
                    this.bridges.forEach(b => { if(b.from===n.id || b.to===n.id) cur+=b.count; });
                    
                    let fill="#1c1917", stroke="#57534e", r=16;
                    if(cur === n.req) { fill="#083344"; stroke="#0891b2"; }
                    if(cur > n.req) { fill="#450a0a"; stroke="#ef4444"; }
                    
                    // Drag highlight
                    if(this.drag.active) {
                        if(n.id===this.drag.start) { stroke="#fbbf24"; }
                        if(n.id===this.drag.target) { r=20; }
                    }


                    // Glow class
                    let cls = (cur===n.req) ? 'class="glow"' : '';
                    
                    html += `<circle cx="${p.x}" cy="${p.y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="2" ${cls}/>`;
                    html += `<text x="${p.x}" y="${p.y}" dy="5" text-anchor="middle" fill="${cur===n.req?'#22d3ee':'#d6d3d1'}" font-weight="bold" font-size="14" pointer-events="none">${n.req}</text>`;