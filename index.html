<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS - Advanced Interaction</title>
    <style>
        /* THEME CONFIG */
        :root { 
            --bg: #09090b; 
            --panel: #18181b; 
            --accent: #22d3ee; 
            --hint: #c084fc; 
            --text: #e4e4e7;
            --dim: #52525b;
            --error: #ef4444;
            --success: #22d3ee;
            --node-fill-complete: #083344;
        }

        /* LAYOUT BASE */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg); color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            gap: 1rem;
        }

        /* HEADER */
        .header { text-align: center; flex-shrink: 0; z-index: 10; width: 100%; padding: 0 1rem; }
        h1 {
            font-size: 2rem; letter-spacing: 0.4em; margin: 0;
            color: var(--accent); text-shadow: 0 0 15px rgba(34, 211, 238, 0.4);
            font-weight: 300; line-height: 1.2;
        }
        .status-bar {
            font-size: 0.8rem; letter-spacing: 0.05em; color: var(--dim);
            text-transform: uppercase; font-weight: bold;
            display: flex; align-items: center; justify-content: center; gap: 0.5em;
            margin-top: 0.5rem; min-height: 1.5em;
            transition: color 0.3s;
        }
        .status-dot { width: 6px; height: 6px; background: var(--dim); border-radius: 50%; transition: 0.3s; }
        
        /* Stati Status Bar */
        .status-bar.ok { color: var(--success); }
        .status-bar.ok .status-dot { background: var(--success); box-shadow: 0 0 8px var(--success); }
        
        .status-bar.err { color: var(--error); }
        .status-bar.err .status-dot { background: var(--error); box-shadow: 0 0 8px var(--error); }
        
        .status-bar.hint-active { color: var(--hint); }
        .status-bar.hint-active .status-dot { background: var(--hint); box-shadow: 0 0 8px var(--hint); }

        /* GAME BOARD */
        .game-board {
            position: relative;
            background: var(--panel);
            border: 1px solid #27272a;
            border-radius: 1.5rem;
            box-shadow: 0 10px 40px -10px rgba(0,0,0,0.8);
            aspect-ratio: 1/1;
            width: 92vw; max-width: 600px;
            max-height: calc(100vh - 180px);
            flex-shrink: 1; 
        }
        svg { width: 100%; height: 100%; display: block; cursor: crosshair; border-radius: 1.5rem; }

        /* CONTROLLI */
        .controls-bar {
            position: relative; 
            display: flex; gap: 1.5rem;
            background: rgba(24, 24, 27, 0.5);
            padding: 0.6rem 2rem;
            border-radius: 3rem;
            border: 1px solid #27272a;
            flex-shrink: 0;
        }

        .btn-icon {
            background: transparent; border: none; color: var(--dim);
            width: 3.2rem; height: 3.2rem; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .btn-icon:active { transform: scale(0.85); }
        .btn-icon:hover { color: var(--text); background: #27272a; }
        .btn-icon svg { width: 1.6rem; height: 1.6rem; pointer-events: none; stroke-width: 2px; }
        
        #btn-hint:hover { color: var(--hint); }
        #btn-next:hover { color: var(--success); }

        /* OVERLAYS */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(9, 9, 11, 0.95);
            backdrop-filter: blur(8px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.4s ease;
            border-radius: 1.5rem; z-index: 50; padding: 2rem; text-align: center;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        .btn-main {
            background: var(--success); color: #000; border: none;
            padding: 1rem 3rem; font-weight: bold; border-radius: 2rem;
            cursor: pointer; margin-top: 2rem; font-family: inherit;
            text-transform: uppercase; letter-spacing: 0.1em;
            box-shadow: 0 0 30px rgba(34, 211, 238, 0.4);
            transition: transform 0.2s;
        }
        .btn-main:active { transform: scale(0.95); }

        /* ANIMAZIONI & CLASSI SVG */
        @keyframes pulse-success { 0% { stroke-opacity: 1; } 50% { stroke-opacity: 0.6; } 100% { stroke-opacity: 1; } }
        
        .node-base { transition: fill 0.3s, stroke 0.3s; }
        .node-complete { 
            stroke: var(--success); 
            fill: var(--node-fill-complete); 
            filter: drop-shadow(0 0 8px rgba(34, 211, 238, 0.3));
            animation: pulse-success 3s infinite;
        }
        .node-error { stroke: var(--error); fill: #3f1313; }
        
        /* Hint Animation */
        @keyframes hint-pulse { 0% { stroke-width: 2; stroke-opacity:0.5; } 50% { stroke-width: 5; stroke-opacity:1; } 100% { stroke-width: 2; stroke-opacity:0.5; } }
        .node-hint { stroke: var(--hint) !important; animation: hint-pulse 1s infinite; }
        
    </style>
</head>
<body>

    <div class="header">
        <h1>NEXUS</h1>
        <div id="status" class="status-bar"><div class="status-dot"></div><span id="status-msg">SISTEMA ONLINE</span></div>
    </div>

    <div id="game-container" class="game-board">
        <svg id="canvas" viewBox="0 0 360 360"></svg>
        
        <!-- WIN SCREEN -->
        <div id="win-overlay" class="overlay">
            <svg style="width: 100px; height: 100px; color: var(--success); margin-bottom:1rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
            <h2 style="margin:0; font-size: 2rem; letter-spacing: 0.2em; color:white; font-weight: 300;">COMPLETO</h2>
            <button id="btn-next-win" class="btn-main">Prossimo</button>
        </div>
    </div>

    <div class="controls-bar">
        <button id="btn-reset" class="btn-icon" title="Reset Plancia">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        </button>
        <button id="btn-hint" class="btn-icon" title="Suggerimento">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-1 1.5-2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"></path><path d="M9 18h6"></path><path d="M10 22h4"></path></svg>
        </button>
        <button id="btn-next" class="btn-icon" title="Nuovo Livello">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M5 12h14"></path><path d="m12 5 7 7-7 7"></path></svg>
        </button>
    </div>

    <script>
        const CONFIG = {
            GRID: 7,
            CELL: 50,
            PAD: 30,
            SIZE: 360,
            NODE_RADIUS: 20, 
            HIT_RADIUS: 28 
        };

        class NexusGame {
            constructor() {
                this.svg = document.getElementById('canvas');
                this.winOverlay = document.getElementById('win-overlay');
                this.statusMsg = document.getElementById('status-msg');
                this.statusBox = document.getElementById('status');
                
                this.level = [];
                this.bridges = [];
                this.solution = []; // Memorizza la soluzione generata per gli hint
                this.hintState = null; // { targetNodeId, message }
                this.drag = { active: false, start: null, curr: null, target: null, valid: false };

                // Event Listeners
                this.svg.addEventListener('pointerdown', e => this.handleDown(e));
                window.addEventListener('pointermove', e => this.handleMove(e));
                window.addEventListener('pointerup', e => this.handleUp(e));
                
                document.getElementById('btn-reset').onclick = () => this.resetBoard();
                document.getElementById('btn-next').onclick = () => this.newLevel();
                document.getElementById('btn-next-win').onclick = () => this.newLevel();
                document.getElementById('btn-hint').onclick = () => this.provideHint();

                this.newLevel();
            }

            // --- AI HINT SYSTEM ---
            provideHint() {
                this.hintState = null;
                
                // 1. Cerca errori: Ponti che NON esistono nella soluzione
                // O ponti con conteggio sbagliato (es. 2 invece di 1)
                for(let b of this.bridges) {
                    const solBridge = this.solution.find(s => 
                        (s.p1.id === b.from && s.p2.id === b.to) || 
                        (s.p1.id === b.to && s.p2.id === b.from)
                    );

                    // Se il ponte non esiste nella soluzione OPPURE il conteggio è superiore alla soluzione
                    if (!solBridge || b.count > solBridge.count) {
                        this.hintState = { 
                            nodes: [b.from, b.to], 
                            message: "COLLEGAMENTO IN ECCESSO. RIMUOVI." 
                        };
                        this.setStatus(this.hintState.message, "hint-active");
                        this.render();
                        return;
                    }
                }

                // 2. Cerca mancanze: Nodi che hanno meno connessioni del necessario
                // Scegliamo un nodo che nella soluzione ha un collegamento non ancora fatto
                for(let solBridge of this.solution) {
                    const currentBridge = this.bridges.find(b => 
                        (b.from === solBridge.p1.id && b.to === solBridge.p2.id) ||
                        (b.from === solBridge.p2.id && b.to === solBridge.p1.id)
                    );

                    // Se manca il ponte o è inferiore
                    if (!currentBridge || currentBridge.count < solBridge.count) {
                        // Determina quale dei due nodi suggerire (quello con più bisogno)
                        const n1 = this.level.find(n => n.id === solBridge.p1.id);
                        // Suggeriamo solo se il nodo non è già "pieno" (anche se in modo errato, ma quello lo copre il punto 1)
                        // Qui assumiamo che se siamo arrivati al punto 2, non ci sono ponti "sbagliati"
                        
                        this.hintState = {
                            nodes: [n1.id, solBridge.p2.id],
                            message: "COLLEGAMENTO RICHIESTO QUI."
                        };
                        this.setStatus(this.hintState.message, "hint-active");
                        this.render();
                        
                        // Auto-hide dopo 4 secondi
                        setTimeout(() => {
                            if(this.hintState) {
                                this.hintState = null;
                                this.setStatus("SISTEMA ONLINE", "");
                                this.render();
                            }
                        }, 4000);
                        return;
                    }
                }
                
                this.setStatus("NESSUN SUGGERIMENTO DISPONIBILE", "");
            }

            // --- LEVEL GEN ---
            generate() {
                let bestLevel = null;
                for(let k=0; k<10; k++) {
                    const candidate = this.tryGenerateBoard();
                    if(candidate && (!bestLevel || (candidate.nodes.length >= 7 && candidate.nodes.length <= 12))) {
                        bestLevel = candidate;
                    }
                }
                if (bestLevel) {
                    this.level = bestLevel.nodes;
                    this.solution = bestLevel.bridges; // Salviamo la soluzione!
                } else {
                    const fb = this.getFallbackLevel();
                    this.level = fb.nodes;
                    this.solution = fb.bridges;
                }
            }

            tryGenerateBoard() {
                let nodes = [];
                for(let y=0; y<CONFIG.GRID; y++) for(let x=0; x<CONFIG.GRID; x++) {
                    if(Math.random() > 0.60) nodes.push({x, y, id: `${x}-${y}`, req: 0});
                }
                if(nodes.length < 6) return null;

                let connected = [nodes[0]];
                let pool = nodes.slice(1);
                let solutionBridges = []; 

                while(pool.length > 0) {
                    let possibleMoves = [];
                    for(let c of connected) {
                        for(let p of pool) {
                            if(this.isPathClear(c, p, nodes, solutionBridges)) possibleMoves.push({src:c, dst:p});
                        }
                    }
                    if(possibleMoves.length === 0) return null;
                    
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    const count = Math.random() > 0.65 ? 2 : 1;
                    
                    solutionBridges.push({p1: move.src, p2: move.dst, count: count});
                    connected.push(move.dst);
                    pool = pool.filter(n => n !== move.dst);
                }

                for(let i=0; i<4; i++) {
                    const n1 = nodes[Math.floor(Math.random()*nodes.length)];
                    const n2 = nodes[Math.floor(Math.random()*nodes.length)];
                    if(n1 !== n2 && this.isPathClear(n1, n2, nodes, solutionBridges)) {
                        solutionBridges.push({p1: n1, p2: n2, count: 1});
                    }
                }

                nodes.forEach(n => {
                    n.req = 0;
                    solutionBridges.forEach(b => { if(b.p1===n || b.p2===n) n.req += b.count; });
                });

                return { 
                    nodes: nodes.filter(n => n.req > 0 && n.req <= 8),
                    bridges: solutionBridges 
                };
            }

            getFallbackLevel() {
                const nodes = [{x:1,y:1,req:2,id:'a'},{x:5,y:1,req:2,id:'b'},{x:1,y:5,req:2,id:'c'},{x:5,y:5,req:2,id:'d'}];
                const bridges = [
                    {p1: nodes[0], p2: nodes[1], count: 1},
                    {p1: nodes[1], p2: nodes[3], count: 1},
                    {p1: nodes[3], p2: nodes[2], count: 1},
                    {p1: nodes[2], p2: nodes[0], count: 1}
                ];
                return { nodes, bridges };
            }

            // --- LOGICA SPAZIALE ---
            isPathClear(n1, n2, allNodes, bridges) {
                if(n1.x !== n2.x && n1.y !== n2.y) return false;
                const minX=Math.min(n1.x,n2.x), maxX=Math.max(n1.x,n2.x);
                const minY=Math.min(n1.y,n2.y), maxY=Math.max(n1.y,n2.y);

                for(let n of allNodes) {
                    if(n===n1 || n===n2) continue;
                    if(n.x >= minX && n.x <= maxX && n.y >= minY && n.y <= maxY && (n.x===n1.x || n.y===n1.y)) return false;
                }
                
                for(let b of bridges) {
                    if('p1' in b) { 
                        if((b.p1===n1 && b.p2===n2) || (b.p1===n2 && b.p2===n1)) continue;
                    } else { 
                        if((b.from===n1.id && b.to===n2.id) || (b.from===n2.id && b.to===n1.id)) continue;
                    }

                    const bp1 = 'p1' in b ? b.p1 : this.level.find(n=>n.id===b.from);
                    const bp2 = 'p2' in b ? b.p2 : this.level.find(n=>n.id===b.to);

                    if(this.intersects(n1, n2, bp1, bp2)) return false;
                    
                    if((n1.x===n2.x && bp1.x===bp2.x && n1.x===bp1.x) || (n1.y===n2.y && bp1.y===bp2.y && n1.y===bp1.y)) {
                        const s1_min = n1.x===n2.x ? minY : minX;
                        const s1_max = n1.x===n2.x ? maxY : maxX;
                        const s2_min = bp1.x===bp2.x ? Math.min(bp1.y,bp2.y) : Math.min(bp1.x,bp2.x);
                        const s2_max = bp1.x===bp2.x ? Math.max(bp1.y,bp2.y) : Math.max(bp1.x,bp2.x);
                        if(Math.max(s1_min, s2_min) < Math.min(s1_max, s2_max)) return false;
                    }
                }
                return true;
            }

            intersects(a, b, c, d) {
                let v1 = a.x===b.x, v2 = c.x===d.x;
                if(v1 === v2) return false;
                let x1=Math.min(a.x,b.x), x2=Math.max(a.x,b.x), y1=Math.min(a.y,b.y), y2=Math.max(a.y,b.y);
                let x3=Math.min(c.x,d.x), x4=Math.max(c.x,d.x), y3=Math.min(c.y,d.y), y4=Math.max(c.y,d.y);
                return v1 ? (x1>x3 && x1<x4 && y3>y1 && y3<y2) : (x3>x1 && x3<x2 && y1>y3 && y1<y4);
            }

            getPos(e) {
                const rect = this.svg.getBoundingClientRect();
                return { 
                    x: (e.clientX - rect.left) * (360 / rect.width), 
                    y: (e.clientY - rect.top) * (360 / rect.height)
                };
            }

            // --- INPUT ---
            handleDown(e) {
                const pos = this.getPos(e);
                
                // 1. DRAG START (Priorità)
                for(let n of this.level) {
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < CONFIG.HIT_RADIUS) {
                        this.drag = { active: true, start: n.id, curr: pos, target: null, valid: false };
                        this.hintState = null; 
                        this.setStatus("TRASCINA...", "ok");
                        this.render(); return; 
                    }
                }

                // 2. CLICK CANCELLAZIONE (Backup)
                for(let i=0; i<this.bridges.length; i++) {
                    const b = this.bridges[i];
                    const n1 = this.level.find(n=>n.id===b.from), n2 = this.level.find(n=>n.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    
                    const lenSq = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
                    let t = ((pos.x-p1.x)*(p2.x-p1.x) + (pos.y-p1.y)*(p2.y-p1.y)) / lenSq;
                    
                    if (t < 0.2 || t > 0.8) continue;

                    const proj = { x: p1.x + t*(p2.x-p1.x), y: p1.y + t*(p2.y-p1.y) };
                    if(Math.hypot(pos.x-proj.x, pos.y-proj.y) < 20) { 
                        if(b.count===2) b.count=1; else this.bridges.splice(i,1);
                        this.render(); this.checkWin(); return;
                    }
                }
            }

            handleMove(e) {
                if(!this.drag.active) return;
                const pos = this.getPos(e);
                this.drag.curr = pos;

                let target = null;
                for(let n of this.level) {
                    if(n.id === this.drag.start) continue;
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < CONFIG.HIT_RADIUS) {
                        target = n.id; break;
                    }
                }

                let valid = false;
                let msg = "CERCA UN NODO";

                if(target) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const dst = this.level.find(x=>x.id===target);
                    const curBridgesObj = this.bridges.map(b => ({
                        p1: this.level.find(x=>x.id===b.from),
                        p2: this.level.find(x=>x.id===b.to)
                    }));
                    if(this.isPathClear(src, dst, this.level, curBridgesObj)) {
                        valid = true; 
                        
                        // Previsione azione (Cosa succederà se rilascio?)
                        const existing = this.bridges.find(b => 
                            (b.from === src.id && b.to === dst.id) || 
                            (b.from === dst.id && b.to === src.id)
                        );
                        if (!existing) msg = "CREA COLLEGAMENTO";
                        else if (existing.count === 1) msg = "RINFORZA (DOPPIO)";
                        else msg = "RIMUOVI COLLEGAMENTI"; // Cycle 3: Delete
                        
                    } else msg = "PERCORSO OSTRUITO";
                } else {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    if(Math.abs(pos.x-p.x) > Math.abs(pos.y-p.y)) { pos.y = p.y; } 
                    else { pos.x = p.x; }
                }

                this.drag.target = target;
                this.drag.valid = valid;
                this.setStatus(msg, valid ? "ok" : (target ? "err" : ""));
                this.render();
            }

            handleUp(e) {
                if(!this.drag.active) return;
                if(this.drag.valid && this.drag.target) {
                    const [id1, id2] = [this.drag.start, this.drag.target].sort();
                    const ex = this.bridges.find(b => b.from===id1 && b.to===id2);
                    if(ex) { 
                        // CICLO: 1 -> 2 -> 0 (Elimina)
                        if(ex.count===1) ex.count=2; 
                        else this.bridges = this.bridges.filter(b=>b!==ex);
                    }
                    else { this.bridges.push({from:id1, to:id2, count:1}); }
                }
                this.drag.active = false;
                this.setStatus("SISTEMA ONLINE", "");
                this.render();
                this.checkWin();
            }

            coord(n) { return { x: n.x * CONFIG.CELL + CONFIG.PAD, y: n.y * CONFIG.CELL + CONFIG.PAD }; }

            setStatus(txt, type) {
                this.statusMsg.textContent = txt;
                this.statusBox.className = "status-bar " + (type || "");
            }

            render() {
                let h = '';
                
                for(let y=0; y<CONFIG.GRID; y++) for(let x=0; x<CONFIG.GRID; x++) {
                    const p = this.coord({x,y});
                    h += `<circle cx="${p.x}" cy="${p.y}" r="1" fill="#27272a"/>`;
                }

                this.bridges.forEach(b => {
                    const n1 = this.level.find(x=>x.id===b.from);
                    const n2 = this.level.find(x=>x.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    const off = 3;
                    
                    h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="transparent" stroke-width="20" stroke-linecap="round"/>`;
                    
                    if(b.count === 1) {
                         h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#06b6d4" stroke-width="4" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    } else {
                        const v = n1.x===n2.x;
                        h += `<line x1="${v?p1.x-off:p1.x}" y1="${v?p1.y:p1.y-off}" x2="${v?p2.x-off:p2.x}" y2="${v?p2.y:p2.y-off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                        h += `<line x1="${v?p1.x+off:p1.x}" y1="${v?p1.y:p1.y+off}" x2="${v?p2.x+off:p2.x}" y2="${v?p2.y:p2.y+off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    }
                });

                if(this.drag.active) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    let end = this.drag.curr;
                    let color = "#fbbf24"; 

                    if(this.drag.target) {
                        const t = this.level.find(x=>x.id===this.drag.target);
                        end = this.coord(t);
                        color = this.drag.valid ? "#22d3ee" : "#ef4444";
                    }
                    h += `<line x1="${p.x}" y1="${p.y}" x2="${end.x}" y2="${end.y}" stroke="${color}" stroke-width="2" stroke-dasharray="5,5"/>`;
                }

                this.level.forEach(n => {
                    const p = this.coord(n);
                    let cur = 0;
                    this.bridges.forEach(b => { if(b.from===n.id || b.to===n.id) cur+=b.count; });
                    
                    let cls = "node-base";
                    let fill="#18181b", stroke="#52525b";

                    // Hint Highlight
                    if(this.hintState && this.hintState.nodes.includes(n.id)) {
                        cls += " node-hint";
                    }

                    if(cur===n.req) { cls="node-complete"; } 
                    else if(cur>n.req) { cls="node-error"; } 

                    if(this.drag.active) {
                        if(n.id===this.drag.start) { stroke="#fbbf24"; }
                        if(n.id===this.drag.target) { stroke="#fff"; }
                    }

                    h += `<circle cx="${p.x}" cy="${p.y}" r="${CONFIG.NODE_RADIUS}" fill="${fill}" stroke="${stroke}" stroke-width="2" class="${cls}"/>`;
                    h += `<text x="${p.x}" y="${p.y}" dy="7" text-anchor="middle" fill="${cur===n.req?'#fff':'#a1a1aa'}" font-weight="bold" font-size="20" pointer-events="none">${n.req}</text>`;
                });

                this.svg.innerHTML = h;
            }

            checkWin() {
                const ok = this.level.every(n => {
                    let c=0; this.bridges.forEach(b=>{if(b.from===n.id||b.to===n.id)c+=b.count});
                    return c===n.req;
                });
                if(!ok) return;
                
                let adj={}; this.level.forEach(n=>adj[n.id]=[]);
                this.bridges.forEach(b=>{adj[b.from].push(b.to); adj[b.to].push(b.from);});
                let q=[this.level[0].id], vis=new Set([this.level[0].id]);
                while(q.length){
                    let curr=q.pop();
                    for(let x of adj[curr]) if(!vis.has(x)) { vis.add(x); q.push(x); }
                }
                
                if(vis.size === this.level.length) {
                    this.winOverlay.classList.add('active');
                }
            }

            resetBoard() {
                this.bridges = [];
                this.render();
                this.winOverlay.classList.remove('active');
            }

            newLevel() {
                this.bridges = [];
                this.generate();
                this.render();
                this.winOverlay.classList.remove('active');
            }
        }

        window.onload = () => new NexusGame();
    </script>
</body>
</html>