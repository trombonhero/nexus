<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS - Stable</title>
    <style>
        /* BASE */
        :root { --bg: #0c0a09; --text: #e7e5e4; --accent: #06b6d4; --panel: #1c1917; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg); color: var(--text);
            font-family: monospace;
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* UI ELEMENTS */
        h1 {
            font-size: 3rem; letter-spacing: 0.2em; margin: 0;
            color: var(--accent); text-shadow: 0 0 20px rgba(6, 182, 212, 0.4);
            font-weight: 300;
        }
        .status {
            font-size: 0.8rem; letter-spacing: 0.2em; color: #78716c;
            margin-bottom: 2rem; text-transform: uppercase; font-weight: bold;
            min-height: 1.2em;
        }

        /* GAME BOARD */
        .game-board {
            position: relative;
            background: var(--panel);
            border: 2px solid #292524;
            border-radius: 1rem;
            box-shadow: 0 20px 50px -10px rgba(0,0,0,0.5);
            /* Dimensioni fisse di fallback per evitare collassi */
            width: 380px; height: 380px; 
            max-width: 95vw; max-height: 95vw;
        }
        svg { width: 100%; height: 100%; display: block; cursor: crosshair; }

        /* BUTTONS */
        .controls { display: flex; gap: 1rem; margin-top: 2rem; }
        .btn-icon {
            background: var(--panel); border: 1px solid #44403c; color: #a8a29e;
            width: 3.5rem; height: 3.5rem; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s;
        }
        .btn-icon:active { transform: scale(0.9); background: #292524; }
        .btn-icon svg { width: 1.5rem; height: 1.5rem; pointer-events: none; }

        /* OVERLAYS */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(12, 10, 9, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            border-radius: 0.8rem; z-index: 10; padding: 2rem; text-align: center;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        .btn-main {
            background: var(--accent); color: #000; border: none;
            padding: 1rem 2rem; font-weight: bold; border-radius: 2rem;
            cursor: pointer; margin-top: 1rem; font-family: monospace;
            text-transform: uppercase; letter-spacing: 0.1em;
        }

        /* DEBUG ERROR BOX */
        #error-log {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: #7f1d1d; color: white; padding: 1rem;
            font-size: 0.8rem; display: none; z-index: 9999;
        }
    </style>
</head>
<body>

    <!-- HEADER -->
    <h1>NEXUS</h1>
    <div id="status" class="status">INIZIALIZZAZIONE...</div>

    <!-- MAIN BOARD -->
    <div id="game-container" class="game-board">
        <svg id="canvas" viewBox="0 0 380 380"></svg>
        
        <!-- WIN SCREEN -->
        <div id="win-overlay" class="overlay">
            <div style="font-size: 4rem; color: var(--accent); margin-bottom: 1rem;">&#10003;</div>
            <h2 style="margin:0; font-size: 2rem;">CONNESSO</h2>
            <button id="btn-next" class="btn-main">Prossimo Livello</button>
        </div>

        <!-- HELP SCREEN -->
        <div id="help-overlay" class="overlay">
            <h3 style="color:var(--accent)">GUIDA</h3>
            <ul style="text-align: left; font-size: 0.9rem; color: #d6d3d1; line-height: 1.8;">
                <li>Trascina per unire le isole</li>
                <li>Il numero = ponti necessari</li>
                <li>Clicca sui ponti per rimuoverli</li>
                <li>Nessun incrocio permesso</li>
            </ul>
            <button id="btn-close-help" class="btn-main" style="background:#44403c; color:white;">Chiudi</button>
        </div>
    </div>

    <!-- CONTROLS -->
    <div class="controls">
        <button id="btn-reset" class="btn-icon" title="Ricomincia">
            <!-- Icona Reset -->
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        </button>
        <button id="btn-help" class="btn-icon" title="Aiuto">
            <!-- Icona Info -->
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
        </button>
    </div>

    <div id="error-log"></div>

    <script>
        // --- GESTORE ERRORI GLOBALE ---
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('error-log');
            el.style.display = 'block';
            el.innerHTML += `ERRORE: ${msg} (Linea ${line})<br>`;
        };

        // --- COSTANTI ---
        const CONFIG = {
            GRID: 7,
            CELL: 50,
            PAD: 15, // Padding ridotto per centrare meglio
            SIZE: 380 // 7*50 + 15*2 = 380
        };

        class NexusGame {
            constructor() {
                this.svg = document.getElementById('canvas');
                this.status = document.getElementById('status');
                
                this.level = [];
                this.bridges = [];
                this.drag = { active: false, start: null, curr: null, target: null, valid: false };

                // Event Listeners (Mouse & Touch)
                this.svg.addEventListener('pointerdown', e => this.handleDown(e));
                window.addEventListener('pointermove', e => this.handleMove(e));
                window.addEventListener('pointerup', e => this.handleUp(e));
                
                // Binding bottoni
                document.getElementById('btn-reset').onclick = () => this.restart();
                document.getElementById('btn-next').onclick = () => this.newLevel();
                document.getElementById('btn-help').onclick = () => document.getElementById('help-overlay').classList.add('active');
                document.getElementById('btn-close-help').onclick = () => document.getElementById('help-overlay').classList.remove('active');

                // Avvio sicuro
                this.initFallbackLevel(); 
            }

            // LEVEL GENERATOR
            generate() {
                try {
                    let nodes = [];
                    let attempts = 0;
                    while(attempts < 50) {
                        attempts++;
                        nodes = [];
                        // Grid nodes
                        for(let y=0; y<CONFIG.GRID; y++) {
                            for(let x=0; x<CONFIG.GRID; x++) {
                                if(Math.random() > 0.55) nodes.push({x, y, id: `${x}-${y}`, req: 0});
                            }
                        }
                        if(nodes.length < 5) continue;

                        // Connect nodes logic (Spanning tree)
                        let connected = [nodes[0]];
                        let pool = nodes.slice(1);
                        let testBridges = [];
                        let stuck = false;

                        while(pool.length > 0) {
                            // Find all valid connections
                            let options = [];
                            for(let c of connected) {
                                for(let p of pool) {
                                    if(this.checkPath(c, p, nodes, testBridges)) options.push({src:c, dst:p});
                                }
                            }
                            if(options.length === 0) { stuck=true; break; }
                            
                            let choice = options[Math.floor(Math.random() * options.length)];
                            testBridges.push({p1: choice.src, p2: choice.dst, count: Math.random()>0.5?1:2});
                            connected.push(choice.dst);
                            pool = pool.filter(n => n !== choice.dst);
                        }

                        if(stuck) continue;

                        // Add cycles
                        for(let i=0; i<4; i++) {
                            let n1 = nodes[Math.floor(Math.random()*nodes.length)];
                            let n2 = nodes[Math.floor(Math.random()*nodes.length)];
                            if(n1!==n2 && this.checkPath(n1, n2, nodes, testBridges)) {
                                testBridges.push({p1: n1, p2: n2, count: 1});
                            }
                        }

                        // Set requirements
                        nodes.forEach(n => {
                            n.req = 0;
                            testBridges.forEach(b => { if(b.p1===n || b.p2===n) n.req+=b.count; });
                        });

                        this.level = nodes.filter(n => n.req > 0 && n.req <= 8);
                        if(this.level.length >= 5) return; // Success
                    }
                } catch(e) {
                    console.error("Gen error", e);
                }
                // Fallback if gen fails
                this.initFallbackLevel();
            }

            initFallbackLevel() {
                // Un livello quadrato semplice che funziona SEMPRE
                this.level = [
                    {x:1, y:1, req:2, id:'a'}, {x:5, y:1, req:2, id:'b'},
                    {x:1, y:5, req:2, id:'c'}, {x:5, y:5, req:2, id:'d'}
                ];
                this.bridges = [];
                this.render();
                this.status.textContent = "SISTEMA PRONTO";
            }

            checkPath(n1, n2, allNodes, bridges) {
                if(n1.x !== n2.x && n1.y !== n2.y) return false;
                
                // Bounds
                let minX=Math.min(n1.x,n2.x), maxX=Math.max(n1.x,n2.x);
                let minY=Math.min(n1.y,n2.y), maxY=Math.max(n1.y,n2.y);

                // Obstacles
                for(let n of allNodes) {
                    if(n===n1||n===n2) continue;
                    if(n.x>=minX && n.x<=maxX && n.y>=minY && n.y<=maxY && (n.x===n1.x || n.y===n1.y)) return false;
                }
                
                // Crossings
                for(let b of bridges) {
                    // Check intersection logic simple
                    let v1 = n1.x===n2.x; // Current is vert
                    let v2 = b.p1.x===b.p2.x; // Bridge is vert
                    if(v1===v2) { // Parallel: check overlap
                       if(v1) { // Both Vert
                           if(n1.x===b.p1.x && Math.max(minY, Math.min(b.p1.y,b.p2.y)) < Math.min(maxY, Math.max(b.p1.y,b.p2.y))) return false;
                       } else { // Both Horiz
                           if(n1.y===b.p1.y && Math.max(minX, Math.min(b.p1.x,b.p2.x)) < Math.min(maxX, Math.max(b.p1.x,b.p2.x))) return false;
                       }
                    } else { // Perpendicular
                        let bx = Math.min(b.p1.x, b.p2.x), bx2 = Math.max(b.p1.x, b.p2.x);
                        let by = Math.min(b.p1.y, b.p2.y), by2 = Math.max(b.p1.y, b.p2.y);
                        if(v1) { // Curr Vert, Bridge Horiz
                            if(n1.x > bx && n1.x < bx2 && b.p1.y > minY && b.p1.y < maxY) return false;
                        } else { // Curr Horiz, Bridge Vert
                            if(n1.y > by && n1.y < by2 && b.p1.x > minX && b.p1.x < maxX) return false;
                        }
                    }
                }
                return true;
            }

            // INPUT HANDLING
            getPos(e) {
                const rect = this.svg.getBoundingClientRect();
                return { 
                    x: (e.clientX - rect.left) * (380 / rect.width), // Scale correction
                    y: (e.clientY - rect.top) * (380 / rect.height)
                };
            }

            handleDown(e) {
                const pos = this.getPos(e);
                
                // 1. Check clicking bridge to delete
                for(let i=0; i<this.bridges.length; i++) {
                    const b = this.bridges[i];
                    const n1 = this.level.find(n=>n.id===b.from);
                    const n2 = this.level.find(n=>n.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    
                    // Dist point to segment
                    const l2 = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
                    if(l2 === 0) continue;
                    let t = ((pos.x-p1.x)*(p2.x-p1.x) + (pos.y-p1.y)*(p2.y-p1.y)) / l2;
                    t = Math.max(0, Math.min(1, t));
                    const proj = { x: p1.x + t*(p2.x-p1.x), y: p1.y + t*(p2.y-p1.y) };
                    const dist = Math.sqrt((pos.x-proj.x)**2 + (pos.y-proj.y)**2);
                    
                    if(dist < 15) {
                        if(b.count===2) b.count=1; else this.bridges.splice(i,1);
                        this.render(); this.checkWin(); return;
                    }
                }

                // 2. Check clicking island to drag
                for(let n of this.level) {
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < 25) {
                        this.drag = { active: true, start: n.id, curr: pos, target: null, valid: false };
                        this.status.textContent = "TRASCINA...";
                        this.render();
                        return;
                    }
                }
            }

            handleMove(e) {
                if(!this.drag.active) return;
                const pos = this.getPos(e);
                this.drag.curr = pos;

                let target = null;
                for(let n of this.level) {
                    if(n.id === this.drag.start) continue;
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < 25) {
                        target = n.id; break;
                    }
                }

                // Validate logic on fly
                let valid = false;
                if(target) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const dst = this.level.find(x=>x.id===target);
                    // Create temp bridge list for validation
                    const tempBridges = this.bridges.map(b => ({
                        p1: this.level.find(x=>x.id===b.from),
                        p2: this.level.find(x=>x.id===b.to)
                    }));
                    if(this.checkPath(src, dst, this.level, tempBridges)) valid = true;
                }

                // Axis Snap for guide line
                if(!target) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    if(Math.abs(pos.x-p.x) > Math.abs(pos.y-p.y)) pos.y = p.y; else pos.x = p.x;
                }

                this.drag.target = target;
                this.drag.valid = valid;
                this.render();
            }

            handleUp(e) {
                if(!this.drag.active) return;
                if(this.drag.valid && this.drag.target) {
                    const u = this.drag.start, v = this.drag.target;
                    // Sort IDs to avoid dupes
                    const [id1, id2] = [u, v].sort();
                    const ex = this.bridges.find(b => b.from===id1 && b.to===id2);
                    if(ex) { if(ex.count===1) ex.count=2; else this.bridges=this.bridges.filter(b=>b!==ex); }
                    else { this.bridges.push({from:id1, to:id2, count:1}); }
                }
                this.drag.active = false;
                this.status.textContent = "SISTEMA ONLINE";
                this.render();
                this.checkWin();
            }

            // RENDERING
            coord(n) { return { x: n.x * CONFIG.CELL + CONFIG.PAD, y: n.y * CONFIG.CELL + CONFIG.PAD }; }

            render() {
                let h = '';
                
                // Grid dots
                for(let y=0; y<CONFIG.GRID; y++) for(let x=0; x<CONFIG.GRID; x++) {
                    const px = x*CONFIG.CELL+CONFIG.PAD, py = y*CONFIG.CELL+CONFIG.PAD;
                    h += `<circle cx="${px}" cy="${py}" r="1" fill="#44403c"/>`;
                }

                // Bridges
                this.bridges.forEach(b => {
                    const n1 = this.level.find(x=>x.id===b.from), n2 = this.level.find(x=>x.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    const off = 3;
                    
                    // Hitbox
                    h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="transparent" stroke-width="20"/>`;
                    
                    if(b.count === 1) {
                         h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#06b6d4" stroke-width="4" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    } else {
                        const v = n1.x===n2.x;
                        h += `<line x1="${v?p1.x-off:p1.x}" y1="${v?p1.y:p1.y-off}" x2="${v?p2.x-off:p2.x}" y2="${v?p2.y:p2.y-off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                        h += `<line x1="${v?p1.x+off:p1.x}" y1="${v?p1.y:p1.y+off}" x2="${v?p2.x+off:p2.x}" y2="${v?p2.y:p2.y+off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    }
                });

                // Drag Line
                if(this.drag.active) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    let color = "#fbbf24";
                    if(this.drag.target) color = this.drag.valid ? "#06b6d4" : "#ef4444";
                    h += `<line x1="${p.x}" y1="${p.y}" x2="${this.drag.curr.x}" y2="${this.drag.curr.y}" stroke="${color}" stroke-width="2" stroke-dasharray="5,5"/>`;
                }

                // Nodes
                this.level.forEach(n => {
                    const p = this.coord(n);
                    let cur = 0;
                    this.bridges.forEach(b => { if(b.from===n.id || b.to===n.id) cur+=b.count; });
                    
                    let f = "#1c1917", s = "#57534e", r = 16;
                    if(cur===n.req) { f="#083344"; s="#0891b2"; }
                    else if(cur>n.req) { f="#450a0a"; s="#ef4444"; }

                    // Highlight target
                    if(this.drag.active && this.drag.target===n.id) { r=20; }
                    
                    // SVG elements
                    h += `<circle cx="${p.x}" cy="${p.y}" r="${r}" fill="${f}" stroke="${s}" stroke-width="2"/>`;
                    h += `<text x="${p.x}" y="${p.y}" dy="5" text-anchor="middle" fill="${cur===n.req?'#22d3ee':'#d6d3d1'}" font-weight="bold" font-size="14" pointer-events="none">${n.req}</text>`;
                });

                this.svg.innerHTML = h;
            }

            checkWin() {
                const ok = this.level.every(n => {
                    let c=0; this.bridges.forEach(b=>{if(b.from===n.id||b.to===n.id)c+=b.count});
                    return c===n.req;
                });
                if(!ok) return;
                
                // BFS Connectivity
                let adj={}; this.level.forEach(n=>adj[n.id]=[]);
                this.bridges.forEach(b=>{adj[b.from].push(b.to); adj[b.to].push(b.from);});
                let q=[this.level[0].id], vis=new Set([this.level[0].id]);
                while(q.length){
                    let curr=q.pop();
                    for(let x of adj[curr]) if(!vis.has(x)) { vis.add(x); q.push(x); }
                }
                if(vis.size === this.level.length) {
                    document.getElementById('win-overlay').classList.add('active');
                }
            }

            restart() {
                this.bridges = [];
                this.render();
                document.getElementById('win-overlay').classList.remove('active');
            }

            newLevel() {
                this.bridges = [];
                this.generate();
                this.render();
                document.getElementById('win-overlay').classList.remove('active');
            }
        }

        // INIT
        window.onload = function() {
            try {
                window.game = new NexusGame();
            } catch(e) {
                document.body.innerHTML += `<div style="color:red; margin-top:20px">CRASH: ${e.message}</div>`;
            }
        };
    </script>
</body>
</html>