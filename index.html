<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS - Experience</title>
    <style>
        /* BASE & THEME */
        :root { 
            --bg: #0c0a09; 
            --panel: #1c1917; 
            --accent: #06b6d4; 
            --text: #e7e5e4;
            --text-dim: #78716c;
            --error: #ef4444;
            --success: #22d3ee;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg); color: var(--text);
            font-family: 'Courier New', Courier, monospace; /* Tech feel */
            height: 100vh; width: 100vw;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        /* HEADER */
        h1 {
            font-size: 2.5rem; letter-spacing: 0.3em; margin: 0;
            color: var(--accent); text-shadow: 0 0 15px rgba(6, 182, 212, 0.3);
            font-weight: 400;
        }
        .status {
            font-size: 0.75rem; letter-spacing: 0.15em; color: var(--text-dim);
            margin-bottom: 1.5rem; text-transform: uppercase; font-weight: bold;
            min-height: 1.2em; display: flex; align-items: center; gap: 0.5em;
        }
        .status-dot { width: 8px; height: 8px; background: var(--text-dim); border-radius: 50%; transition: 0.3s; }
        .status.ok .status-dot { background: var(--success); box-shadow: 0 0 8px var(--success); }
        .status.err .status-dot { background: var(--error); box-shadow: 0 0 8px var(--error); }

        /* BOARD */
        .game-board {
            position: relative;
            background: var(--panel);
            border: 1px solid #292524;
            border-radius: 1rem;
            box-shadow: 0 20px 60px -10px rgba(0,0,0,0.6);
            width: 360px; height: 360px; 
            max-width: 90vw; max-height: 90vw;
        }
        svg { width: 100%; height: 100%; display: block; cursor: crosshair; }

        /* UI CONTROLS */
        .controls { display: flex; gap: 1.5rem; margin-top: 2rem; }
        .btn-icon {
            background: transparent; border: 1px solid #44403c; color: var(--text-dim);
            width: 4rem; height: 4rem; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s;
        }
        .btn-icon:active { transform: scale(0.92); background: #292524; color: var(--accent); border-color: var(--accent); }
        .btn-icon svg { width: 1.8rem; height: 1.8rem; pointer-events: none; }

        /* OVERLAYS */
        .overlay {
            position: absolute; inset: 0;
            background: rgba(12, 10, 9, 0.92);
            backdrop-filter: blur(4px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.4s ease;
            border-radius: 1rem; z-index: 20; padding: 2rem; text-align: center;
        }
        .overlay.active { opacity: 1; pointer-events: auto; }
        
        .btn-main {
            background: var(--accent); color: #000; border: none;
            padding: 1rem 2.5rem; font-weight: bold; border-radius: 2rem;
            cursor: pointer; margin-top: 1.5rem; font-family: inherit;
            text-transform: uppercase; letter-spacing: 0.1em;
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.3);
            transition: transform 0.2s;
        }
        .btn-main:active { transform: scale(0.95); }

        /* ANIMATIONS */
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; text-shadow: 0 0 10px var(--success); } 100% { opacity: 0.8; } }
        .node-complete { animation: pulse 3s infinite ease-in-out; }

    </style>
</head>
<body>

    <h1>NEXUS</h1>
    <div id="status" class="status"><div class="status-dot"></div><span id="status-msg">SISTEMA ONLINE</span></div>

    <div id="game-container" class="game-board">
        <svg id="canvas" viewBox="0 0 360 360"></svg>
        
        <!-- WIN SCREEN -->
        <div id="win-overlay" class="overlay">
            <svg style="width: 80px; height: 80px; color: var(--success); margin-bottom:1rem;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
            <h2 style="margin:0; font-size: 1.8rem; letter-spacing: 0.1em; color:white;">SINCRONIZZATO</h2>
            <button id="btn-next" class="btn-main">Prossima Configurazione</button>
        </div>

        <!-- HELP SCREEN -->
        <div id="help-overlay" class="overlay">
            <h3 style="color:var(--accent); letter-spacing: 0.2em; margin-bottom: 1.5rem;">PROTOCOLLO</h3>
            <ul style="text-align: left; font-size: 0.85rem; color: #d6d3d1; line-height: 2; list-style: none; padding:0; margin:0;">
                <li>⦿ Trascina tra i nodi per connetterli</li>
                <li>⦿ Il numero indica i ponti richiesti</li>
                <li>⦿ Tocca una linea per rimuoverla</li>
                <li>⦿ Nessun incrocio permesso</li>
            </ul>
            <button id="btn-close-help" class="btn-main" style="background:#292524; color:white; box-shadow:none; border:1px solid #44403c; margin-top:2rem;">Chiudi</button>
        </div>
    </div>

    <div class="controls">
        <button id="btn-reset" class="btn-icon" title="Reset">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path></svg>
        </button>
        <button id="btn-help" class="btn-icon" title="Info">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
        </button>
    </div>

    <script>
        const CONFIG = {
            GRID: 7,
            CELL: 50,
            PAD: 30, // Padding per non tagliare i bordi
            SIZE: 360, // 6 celle * 50 + 60 pad
            NODE_RADIUS: 18,
            CLICK_TOLERANCE: 22 // Raggio leggermente più grande per il tocco
        };

        class NexusGame {
            constructor() {
                this.svg = document.getElementById('canvas');
                this.statusMsg = document.getElementById('status-msg');
                this.statusBox = document.getElementById('status');
                
                this.level = [];
                this.bridges = [];
                this.drag = { active: false, start: null, curr: null, target: null, valid: false };

                // Gestione Eventi Unificata
                this.svg.addEventListener('pointerdown', e => this.handleDown(e));
                window.addEventListener('pointermove', e => this.handleMove(e));
                window.addEventListener('pointerup', e => this.handleUp(e));
                
                // Binding UI
                document.getElementById('btn-reset').onclick = () => this.restart();
                document.getElementById('btn-next').onclick = () => this.newLevel();
                document.getElementById('btn-help').onclick = () => document.getElementById('help-overlay').classList.add('active');
                document.getElementById('btn-close-help').onclick = () => document.getElementById('help-overlay').classList.remove('active');

                this.newLevel();
            }

            // --- GENERATORE DI LIVELLI MIGLIORATO ---
            generate() {
                let bestLevel = null;
                // Genera 5 candidati e prendi quello con il miglior bilanciamento
                for(let k=0; k<5; k++) {
                    const candidate = this.tryGenerateBoard();
                    if(candidate) {
                        // Criterio di qualità: preferiamo livelli con un numero medio di nodi (tra 7 e 10)
                        if(!bestLevel || (candidate.nodes.length >= 7 && candidate.nodes.length <= 10)) {
                            bestLevel = candidate;
                        }
                    }
                }
                
                if(bestLevel) {
                    this.level = bestLevel.nodes;
                } else {
                    // Fallback di sicurezza estrema
                    this.level = [{x:1,y:1,req:2,id:'a'},{x:5,y:1,req:2,id:'b'},{x:1,y:5,req:2,id:'c'},{x:5,y:5,req:2,id:'d'}];
                }
            }

            tryGenerateBoard() {
                let nodes = [];
                // 1. Griglia sparsa
                for(let y=0; y<CONFIG.GRID; y++) {
                    for(let x=0; x<CONFIG.GRID; x++) {
                        // Densità controllata per non sovraffollare
                        if(Math.random() > 0.65) nodes.push({x, y, id: `${x}-${y}`, req: 0});
                    }
                }
                if(nodes.length < 6) return null;

                // 2. Connessione (Spanning Tree)
                // Usiamo un algoritmo "Greedy" randomizzato per connettere tutto
                let connected = [nodes[0]];
                let pool = nodes.slice(1);
                let solutionBridges = []; // Soluzione interna per calcolare i requisiti

                while(pool.length > 0) {
                    let possibleMoves = [];
                    for(let c of connected) {
                        for(let p of pool) {
                            if(this.isPathClear(c, p, nodes, solutionBridges)) {
                                possibleMoves.push({src:c, dst:p});
                            }
                        }
                    }
                    if(possibleMoves.length === 0) return null; // Vicolo cieco, scarta board
                    
                    // Scegli una connessione random
                    const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                    
                    // 30% di probabilità di doppio ponte immediato (aumenta varietà)
                    const count = Math.random() > 0.7 ? 2 : 1;
                    
                    solutionBridges.push({p1: move.src, p2: move.dst, count: count});
                    connected.push(move.dst);
                    pool = pool.filter(n => n !== move.dst);
                }

                // 3. Aggiungi cicli extra (per non renderlo solo un albero lineare)
                // Cerchiamo di aggiungere ~30% di connessioni in più rispetto al minimo
                const extraLinksTarget = Math.floor(nodes.length * 0.3);
                let extraLinks = 0;
                let attempts = 0;
                
                while(extraLinks < extraLinksTarget && attempts < 50) {
                    attempts++;
                    const n1 = nodes[Math.floor(Math.random()*nodes.length)];
                    const n2 = nodes[Math.floor(Math.random()*nodes.length)];
                    
                    if(n1 !== n2 && this.isPathClear(n1, n2, nodes, solutionBridges)) {
                        // Non vogliamo troppi doppi ponti nei cicli extra, meglio singoli per chiudere
                        solutionBridges.push({p1: n1, p2: n2, count: 1});
                        extraLinks++;
                    }
                }

                // 4. Calcola i numeri (Requirements) basandoci sulla soluzione generata
                nodes.forEach(n => {
                    n.req = 0;
                    solutionBridges.forEach(b => { if(b.p1===n || b.p2===n) n.req += b.count; });
                });

                // Filtra nodi isolati (non dovrebbero esserci ma sicurezza)
                return { nodes: nodes.filter(n => n.req > 0 && n.req <= 8) };
            }

            // --- LOGICA DI CONTROLLO SPAZIALE ---
            isPathClear(n1, n2, allNodes, currentBridges) {
                // Deve essere ortogonale
                if(n1.x !== n2.x && n1.y !== n2.y) return false;
                
                // Bounds rect
                const minX=Math.min(n1.x,n2.x), maxX=Math.max(n1.x,n2.x);
                const minY=Math.min(n1.y,n2.y), maxY=Math.max(n1.y,n2.y);

                // Ostacolo Nodo intermedio
                for(let n of allNodes) {
                    if(n===n1 || n===n2) continue;
                    // Se il nodo è esattamente sulla linea tra n1 e n2
                    if(n.x >= minX && n.x <= maxX && n.y >= minY && n.y <= maxY && (n.x===n1.x || n.y===n1.y)) return false;
                }
                
                // Incrocio Ponte
                for(let b of currentBridges) {
                    // Check incrocio geometrico
                    if(this.intersects(n1, n2, b.p1, b.p2)) return false;
                    
                    // Check sovrapposizione parallela (Colineare)
                    // Se sono sulla stessa linea, non devono sovrapporsi
                    if((n1.x===n2.x && b.p1.x===b.p2.x && n1.x===b.p1.x) || 
                       (n1.y===n2.y && b.p1.y===b.p2.y && n1.y===b.p1.y)) {
                        
                        // Calcola range di sovrapposizione
                        const s1_min = n1.x===n2.x ? minY : minX;
                        const s1_max = n1.x===n2.x ? maxY : maxX;
                        const s2_min = b.p1.x===b.p2.x ? Math.min(b.p1.y,b.p2.y) : Math.min(b.p1.x,b.p2.x);
                        const s2_max = b.p1.x===b.p2.x ? Math.max(b.p1.y,b.p2.y) : Math.max(b.p1.x,b.p2.x);
                        
                        // Se si sovrappongono parzialmente o totalmente
                        if(Math.max(s1_min, s2_min) < Math.min(s1_max, s2_max)) return false;
                    }
                }
                return true;
            }

            intersects(a, b, c, d) {
                let v1 = a.x===b.x; // AB è verticale?
                let v2 = c.x===d.x; // CD è verticale?
                if(v1 === v2) return false; // Paralleli (gestiti separatamente)

                let x1=Math.min(a.x,b.x), x2=Math.max(a.x,b.x), y1=Math.min(a.y,b.y), y2=Math.max(a.y,b.y);
                let x3=Math.min(c.x,d.x), x4=Math.max(c.x,d.x), y3=Math.min(c.y,d.y), y4=Math.max(c.y,d.y);

                return v1 ? (x1>x3 && x1<x4 && y3>y1 && y3<y2) : (x3>x1 && x3<x2 && y1>y3 && y1<y4);
            }

            // --- INPUT HANDLING ---
            getPos(e) {
                const rect = this.svg.getBoundingClientRect();
                return { 
                    x: (e.clientX - rect.left) * (360 / rect.width), 
                    y: (e.clientY - rect.top) * (360 / rect.height)
                };
            }

            handleDown(e) {
                const pos = this.getPos(e);
                
                // 1. PRIORITÀ ALLE ISOLE (Drag Start)
                // Risolve il problema di cancellare i ponti quando si clicca un nodo
                for(let n of this.level) {
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < CONFIG.CLICK_TOLERANCE) {
                        this.drag = { active: true, start: n.id, curr: pos, target: null, valid: false };
                        this.setStatus("TRASCINA...", "ok");
                        this.render();
                        return; // Esci subito, non controllare i ponti
                    }
                }

                // 2. CHECK CANCELLAZIONE PONTE
                // Solo se non abbiamo cliccato un'isola
                for(let i=0; i<this.bridges.length; i++) {
                    const b = this.bridges[i];
                    const n1 = this.level.find(n=>n.id===b.from);
                    const n2 = this.level.find(n=>n.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    
                    // Distanza punto-segmento
                    const l2 = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
                    let t = ((pos.x-p1.x)*(p2.x-p1.x) + (pos.y-p1.y)*(p2.y-p1.y)) / l2;
                    t = Math.max(0, Math.min(1, t)); // Clamping
                    
                    // Ignora click troppo vicini agli estremi (per evitare conflitti futuri)
                    if (t < 0.1 || t > 0.9) continue;

                    const proj = { x: p1.x + t*(p2.x-p1.x), y: p1.y + t*(p2.y-p1.y) };
                    const dist = Math.sqrt((pos.x-proj.x)**2 + (pos.y-proj.y)**2);
                    
                    if(dist < 15) { // Hitbox ponte
                        if(b.count===2) b.count=1; else this.bridges.splice(i,1);
                        this.render(); this.checkWin(); return;
                    }
                }
            }

            handleMove(e) {
                if(!this.drag.active) return;
                const pos = this.getPos(e);
                this.drag.curr = pos;

                // Trova target vicino
                let target = null;
                for(let n of this.level) {
                    if(n.id === this.drag.start) continue;
                    const p = this.coord(n);
                    if(Math.hypot(pos.x-p.x, pos.y-p.y) < CONFIG.CLICK_TOLERANCE) {
                        target = n.id; break;
                    }
                }

                // Validazione al volo
                let valid = false;
                let msg = "CERCA UN NODO";
                
                if(target) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const dst = this.level.find(x=>x.id===target);
                    // Mock bridge per check
                    const currentBridgesAsObjects = this.bridges.map(b => ({
                        p1: this.level.find(x=>x.id===b.from),
                        p2: this.level.find(x=>x.id===b.to)
                    }));
                    if(this.isPathClear(src, dst, this.level, currentBridgesAsObjects)) {
                        valid = true; msg = "RILASCIA PER CONNETTERE";
                    } else {
                        msg = "PERCORSO OSTRUITO";
                    }
                } else {
                    // Axis Snap visivo per aiutare
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    if(Math.abs(pos.x-p.x) > Math.abs(pos.y-p.y)) msg="ORIZZONTALE...";
                    else msg="VERTICALE...";
                }

                this.drag.target = target;
                this.drag.valid = valid;
                this.setStatus(msg, valid ? "ok" : (target ? "err" : ""));
                this.render();
            }

            handleUp(e) {
                if(!this.drag.active) return;
                
                if(this.drag.valid && this.drag.target) {
                    const [id1, id2] = [this.drag.start, this.drag.target].sort();
                    // Controlla se esiste già
                    const ex = this.bridges.find(b => b.from===id1 && b.to===id2);
                    
                    if(ex) {
                        // Ciclo: 1 -> 2 -> 0 (rimuovi)
                        if(ex.count===1) ex.count=2; 
                        else this.bridges = this.bridges.filter(b=>b!==ex);
                    } else {
                        this.bridges.push({from:id1, to:id2, count:1});
                    }
                }
                
                this.drag.active = false;
                this.setStatus("SISTEMA ONLINE", "");
                this.render();
                this.checkWin();
            }

            // RENDERING
            coord(n) { return { x: n.x * CONFIG.CELL + CONFIG.PAD, y: n.y * CONFIG.CELL + CONFIG.PAD }; }
            
            setStatus(txt, type) {
                this.statusMsg.textContent = txt;
                this.statusBox.className = "status " + (type || "");
            }

            render() {
                let h = '';
                
                // Griglia di sfondo (Dots)
                for(let y=0; y<CONFIG.GRID; y++) for(let x=0; x<CONFIG.GRID; x++) {
                    const p = this.coord({x,y});
                    h += `<circle cx="${p.x}" cy="${p.y}" r="1" fill="#44403c"/>`;
                }

                // Bridges
                this.bridges.forEach(b => {
                    const n1 = this.level.find(x=>x.id===b.from);
                    const n2 = this.level.find(x=>x.id===b.to);
                    const p1 = this.coord(n1), p2 = this.coord(n2);
                    const off = 3;
                    
                    // Hitbox invisibile molto larga per facilitare il click
                    h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="transparent" stroke-width="20" stroke-linecap="round"/>`;
                    
                    if(b.count === 1) {
                         h += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#06b6d4" stroke-width="4" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    } else {
                        const v = n1.x===n2.x;
                        h += `<line x1="${v?p1.x-off:p1.x}" y1="${v?p1.y:p1.y-off}" x2="${v?p2.x-off:p2.x}" y2="${v?p2.y:p2.y-off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                        h += `<line x1="${v?p1.x+off:p1.x}" y1="${v?p1.y:p1.y+off}" x2="${v?p2.x+off:p2.x}" y2="${v?p2.y:p2.y+off}" stroke="#06b6d4" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round"/>`;
                    }
                });

                // Drag Line (guida visiva)
                if(this.drag.active) {
                    const src = this.level.find(x=>x.id===this.drag.start);
                    const p = this.coord(src);
                    let end = this.drag.curr;
                    let color = "#fbbf24"; // Amber (default)

                    if(this.drag.target) {
                        const t = this.level.find(x=>x.id===this.drag.target);
                        end = this.coord(t);
                        color = this.drag.valid ? "#22d3ee" : "#ef4444";
                    } else {
                        // Axis snapping visivo
                        if(Math.abs(end.x-p.x) > Math.abs(end.y-p.y)) end.y = p.y; else end.x = p.x;
                    }
                    h += `<line x1="${p.x}" y1="${p.y}" x2="${end.x}" y2="${end.y}" stroke="${color}" stroke-width="2" stroke-dasharray="5,5"/>`;
                }

                // Nodes (Islands)
                this.level.forEach(n => {
                    const p = this.coord(n);
                    let cur = 0;
                    this.bridges.forEach(b => { if(b.from===n.id || b.to===n.id) cur+=b.count; });
                    
                    let fill="#1c1917", stroke="#57534e", r=CONFIG.NODE_RADIUS;
                    let cls = "";

                    if(cur===n.req) { fill="#083344"; stroke="#0891b2"; cls="node-complete"; } // Completo
                    else if(cur>n.req) { fill="#450a0a"; stroke="#ef4444"; } // Errore (Troppi ponti)

                    // Drag highlight
                    if(this.drag.active) {
                        if(n.id===this.drag.start) { stroke="#fbbf24"; }
                        if(n.id===this.drag.target) { r=22; }
                    }

                    h += `<circle cx="${p.x}" cy="${p.y}" r="${r}" fill="${fill}" stroke="${stroke}" stroke-width="2" class="${cls}"/>`;
                    h += `<text x="${p.x}" y="${p.y}" dy="5" text-anchor="middle" fill="${cur===n.req?'#22d3ee':'#d6d3d1'}" font-weight="bold" font-size="14" pointer-events="none">${n.req}</text>`;
                });

                this.svg.innerHTML = h;
            }

            checkWin() {
                const ok = this.level.every(n => {
                    let c=0; this.bridges.forEach(b=>{if(b.from===n.id||b.to===n.id)c+=b.count});
                    return c===n.req;
                });
                if(!ok) return;
                
                // BFS Connectivity Check
                let adj={}; this.level.forEach(n=>adj[n.id]=[]);
                this.bridges.forEach(b=>{adj[b.from].push(b.to); adj[b.to].push(b.from);});
                let q=[this.level[0].id], vis=new Set([this.level[0].id]);
                while(q.length){
                    let curr=q.pop();
                    for(let x of adj[curr]) if(!vis.has(x)) { vis.add(x); q.push(x); }
                }
                
                if(vis.size === this.level.length) {
                    document.getElementById('win-overlay').classList.add('active');
                }
            }

            restart() {
                this.bridges = [];
                this.render();
                document.getElementById('win-overlay').classList.remove('active');
            }

            newLevel() {
                this.bridges = [];
                this.generate();
                this.render();
                document.getElementById('win-overlay').classList.remove('active');
            }
        }

        // START
        window.onload = () => new NexusGame();
    </script>
</body>
</html>